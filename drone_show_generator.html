import React, { useState, useEffect, useRef } from 'react';
import { 
  Settings, Info, Upload, Type, Image as ImageIcon, Trash2, 
  MousePointer2, Palette, Layers, Grid, Sun, Moon, 
  Lasso, X, BoxSelect, ZoomIn, ZoomOut, Maximize, Move,
  PlusSquare, Film, Play, Pause, Save, Calculator, CheckCircle2
} from 'lucide-react';

// å¼•å…¥ JSZip (é€é CDN å‹•æ…‹è¼‰å…¥)
const loadJSZip = () => {
  return new Promise((resolve, reject) => {
    if (window.JSZip) return resolve(window.JSZip);
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = () => resolve(window.JSZip);
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

export default function DroneShowEditor() {
  // --- æ ¸å¿ƒæ¨¡å¼èˆ‡è¼¸å…¥ ---
  const [mode, setMode] = useState('text'); 
  const [inputText, setInputText] = useState('ğŸ¤–');
  const [fontSize, setFontSize] = useState(300);
  const [imageSrc, setImageSrc] = useState(null);
  
  // --- ç”Ÿæˆåƒæ•¸ ---
  const [drones, setDrones] = useState([]);
  const [density, setDensity] = useState(8);
  const [threshold, setThreshold] = useState(128);
  const [targetTone, setTargetTone] = useState('light');
  const [useImageColor, setUseImageColor] = useState(false);
  const [singleColor, setSingleColor] = useState('#00ffcc');
  
  // --- æ–°å¢ï¼šç›®æ¨™æ•¸é‡æ§åˆ¶ ---
  const [targetCount, setTargetCount] = useState(500);
  const [isAutoFitting, setIsAutoFitting] = useState(false);

  // --- èƒŒæ™¯å»é™¤ ---
  const [bgRemovalEnabled, setBgRemovalEnabled] = useState(false);
  const [removeColor, setRemoveColor] = useState('#ffffff');
  const [removeTolerance, setRemoveTolerance] = useState(30);

  // --- äº’å‹•èˆ‡è¦–åœ– ---
  const [tool, setTool] = useState('view');
  const [selectedIndices, setSelectedIndices] = useState(new Set());
  const [zoom, setZoom] = useState(1);
  const [pan, setPan] = useState({ x: 0, y: 0 });
  const isPanningRef = useRef(false);
  const lastMousePosRef = useRef({ x: 0, y: 0 });
  const lassoPathRef = useRef([]);
  const isDrawingRef = useRef(false);
  
  // --- æ–°å¢ï¼šæ™‚é–“è»¸èˆ‡åŒ¯å‡º ---
  const [frames, setFrames] = useState([]); // Array<{ id, drones, thumbnail }>
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentFrameIndex, setCurrentFrameIndex] = useState(-1); // -1 ä»£è¡¨ç·¨è¼¯æ¨¡å¼ï¼Œ>=0 ä»£è¡¨é è¦½æ¨¡å¼
  const [filenamePrefix, setFilenamePrefix] = useState('drone_show');
  const [isExporting, setIsExporting] = useState(false);

  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const canvasSize = { width: 600, height: 400 };

  // åˆå§‹åŒ– JSZip
  useEffect(() => { loadJSZip().catch(console.error); }, []);

  // è¼”åŠ©ï¼šHex è½‰ RGB
  const hexToRgb = (hex) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
  };

  const isPointInPolygon = (point, vs) => {
    let x = point.x, y = point.y;
    let inside = false;
    for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        let xi = vs[i].x, yi = vs[i].y;
        let xj = vs[j].x, yj = vs[j].y;
        let intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
  };

  const handleImageUpload = (e) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        setImageSrc(event.target.result);
        setMode('image');
        setUseImageColor(true);
        setTargetTone('light');
        setSelectedIndices(new Set());
        setTool('view');
        // ä¿æŒç›®å‰çš„ density è¨­å®šï¼Œä¸é‡ç½®ï¼Œä»¥ç¬¦åˆã€ŒåŒæ¯”ä¾‹ã€éœ€æ±‚
      };
      reader.readAsDataURL(file);
    }
  };

  // --- è‡ªå‹•é©é…æ•¸é‡é‚è¼¯ ---
  const autoFitToCount = async () => {
    if (!canvasRef.current) return;
    setIsAutoFitting(true);
    
    // ç‚ºäº†ä¸å¡ä½ UIï¼Œä½¿ç”¨ç°¡å–®çš„ç•°æ­¥å»¶é²
    await new Promise(r => setTimeout(r, 10));

    // ç°¡å–®çš„äºŒåˆ†æœå°‹æ³•æˆ–è¿­ä»£æ³•ä¾†å°‹æ‰¾æœ€ä½³ density
    let bestDensity = density;
    let minDiff = Infinity;
    
    // ç¯„åœæœå°‹ï¼šå¾ 3 åˆ° 30 (å¯†åº¦)
    // ç‚ºäº†æ•ˆèƒ½ï¼Œæˆ‘å€‘ç”Ÿæˆä¸€æ¬¡ temp canvas
    const canvas = document.createElement('canvas');
    canvas.width = canvasSize.width;
    canvas.height = canvasSize.height;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    
    // ç¹ªè£½ç›®å‰çš„åœ–æ¡ˆåˆ° temp canvas
    if (mode === 'text') {
        ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${fontSize}px "Segoe UI Emoji", "Noto Color Emoji", sans-serif`;
        ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(inputText, canvas.width / 2, canvas.height / 2);
    } else if (imageSrc) {
        const img = new Image();
        img.src = imageSrc;
        await new Promise(resolve => { img.onload = resolve; }); // ç­‰å¾…åœ–ç‰‡è¼‰å…¥
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        ctx.drawImage(img, (canvas.width - img.width * scale) / 2, (canvas.height - img.height * scale) / 2, img.width * scale, img.height * scale);
    }

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    // è¿­ä»£æ¸¬è©¦
    for (let d = 3; d <= 25; d++) {
        const count = calculateDroneCount(imageData, d, threshold, targetTone, bgRemovalEnabled, removeColor, removeTolerance);
        const diff = Math.abs(count - targetCount);
        if (diff < minDiff) {
            minDiff = diff;
            bestDensity = d;
        }
        // å¦‚æœå·²ç¶“å¾ˆæ¥è¿‘ (èª¤å·® 5% å…§)ï¼Œææ—©çµæŸ
        if (diff < targetCount * 0.05) break; 
    }

    setDensity(bestDensity);
    setIsAutoFitting(false);
  };

  // ç´”è¨ˆç®—æ•¸é‡ç”¨çš„å‡½æ•¸
  const calculateDroneCount = (imageData, testDensity, testThreshold, tone, bg, rmColor, rmTol) => {
    let count = 0;
    const { width, height, data } = imageData;
    const rmRGB = bg ? hexToRgb(rmColor) : null;

    for (let y = 0; y < height; y += testDensity) {
      for (let x = 0; x < width; x += testDensity) {
        const index = (y * width + x) * 4;
        const r = data[index]; const g = data[index + 1]; const b = data[index + 2]; const a = data[index + 3];

        if (bg && rmRGB) {
           const dist = Math.sqrt(Math.pow(r-rmRGB.r,2) + Math.pow(g-rmRGB.g,2) + Math.pow(b-rmRGB.b,2));
           if (dist < rmTol * 1.5) continue;
        }

        const bright = (r + g + b) / 3;
        let isSub = tone === 'light' ? (a > 50 && bright > testThreshold) : (a > 50 && bright < testThreshold);
        if (isSub) count++;
      }
    }
    return count;
  };

  // ç”Ÿæˆåœ–æ¡ˆé‚è¼¯
  const generatePattern = () => {
    // å¦‚æœæ­£åœ¨æ’­æ”¾æ™‚é–“è»¸ï¼Œä¸é‡æ–°ç”Ÿæˆç·¨è¼¯å€
    if (isPlaying || currentFrameIndex !== -1) return;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    canvas.width = canvasSize.width;
    canvas.height = canvasSize.height;
    
    if (mode === 'text') {
      ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.font = `bold ${fontSize}px "Segoe UI Emoji", "Noto Color Emoji", sans-serif`;
      ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(inputText, canvas.width / 2, canvas.height / 2);
      processImageData(ctx, 'light');
    } else if (mode === 'image' && imageSrc) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const img = new Image();
      img.src = imageSrc;
      img.onload = () => {
        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
        ctx.drawImage(img, (canvas.width - img.width * scale) / 2, (canvas.height - img.height * scale) / 2, img.width * scale, img.height * scale);
        processImageData(ctx, targetTone);
      };
    } else {
      setDrones([]);
    }
  };

  const processImageData = (ctx, effectiveTone) => {
    const { width, height } = canvasSize;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    const newDrones = [];
    const removeRGB = bgRemovalEnabled ? hexToRgb(removeColor) : null;

    for (let y = 0; y < height; y += density) {
      for (let x = 0; x < width; x += density) {
        const index = (y * width + x) * 4;
        const r = data[index]; const g = data[index + 1]; const b = data[index + 2]; const a = data[index + 3];

        if (bgRemovalEnabled && removeRGB) {
          const dist = Math.sqrt(Math.pow(r - removeRGB.r, 2) + Math.pow(g - removeRGB.g, 2) + Math.pow(b - removeRGB.b, 2));
          if (dist < removeTolerance * 1.5) continue; 
        }

        const brightness = (r + g + b) / 3;
        let isSubject = effectiveTone === 'light' ? (a > 50 && brightness > threshold) : (a > 50 && brightness < threshold);

        if (isSubject) {
          let color = singleColor;
          if (useImageColor) color = `rgb(${r},${g},${b})`;
          newDrones.push({
            x: x, y: y, baseX: x, baseY: y, color: color,
            phase: Math.random() * Math.PI * 2, zOffset: Math.random() * 20
          });
        }
      }
    }
    setDrones(newDrones);
    setSelectedIndices(new Set());
  };

  useEffect(() => {
    const timer = setTimeout(() => { generatePattern(); }, 100);
    return () => clearTimeout(timer);
  }, [inputText, fontSize, imageSrc, mode, density, threshold, targetTone, useImageColor, singleColor, bgRemovalEnabled, removeColor, removeTolerance]);

  // --- æ™‚é–“è»¸åŠŸèƒ½ ---
  const addFrame = () => {
    if (drones.length === 0) return;
    
    // ç”¢ç”Ÿç¸®åœ–
    const thumbCanvas = document.createElement('canvas');
    thumbCanvas.width = 150; thumbCanvas.height = 100;
    const tCtx = thumbCanvas.getContext('2d');
    tCtx.fillStyle = '#0f172a'; tCtx.fillRect(0,0,150,100);
    const scale = 150 / 600;
    drones.forEach(d => {
        tCtx.fillStyle = d.color;
        tCtx.beginPath(); tCtx.arc(d.x * scale, d.y * scale, 1.5, 0, Math.PI*2); tCtx.fill();
    });

    const newFrame = {
        id: Date.now(),
        drones: JSON.parse(JSON.stringify(drones)), // Deep copy
        thumbnail: thumbCanvas.toDataURL()
    };
    
    setFrames(prev => [...prev, newFrame]);
  };

  const deleteFrame = (index, e) => {
      e.stopPropagation();
      setFrames(prev => prev.filter((_, i) => i !== index));
      if (currentFrameIndex === index) setCurrentFrameIndex(-1);
  };

  const playTimeline = () => {
    if (frames.length === 0) return;
    setIsPlaying(!isPlaying);
    if (!isPlaying) setCurrentFrameIndex(0);
    else setCurrentFrameIndex(-1); // Stop
  };

  useEffect(() => {
    let interval;
    if (isPlaying && frames.length > 0) {
        interval = setInterval(() => {
            setCurrentFrameIndex(prev => {
                const next = prev + 1;
                return next >= frames.length ? 0 : next;
            });
        }, 800); // 800ms æ¯å¹€
    }
    return () => clearInterval(interval);
  }, [isPlaying, frames]);

  // --- åŒ¯å‡ºåŠŸèƒ½ ---
  const exportZip = async () => {
    if (frames.length === 0 || !window.JSZip) return;
    setIsExporting(true);

    const zip = new window.JSZip();
    const folder = zip.folder(filenamePrefix || "drone_show");

    // ç¹ªè£½æ¯å€‹ Frame
    for (let i = 0; i < frames.length; i++) {
        const frame = frames[i];
        const canvas = document.createElement('canvas');
        canvas.width = 1920; // åŒ¯å‡ºé«˜è§£æåº¦
        canvas.height = 1080;
        const ctx = canvas.getContext('2d');
        
        // ç•«é»‘åº•
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç•«é» (éœ€ç½®ä¸­æ”¾å¤§)
        const scale = Math.min(canvas.width / 650, canvas.height / 450); // ç¨å¾®ç•™é‚Š
        const offsetX = (canvas.width - 600 * scale) / 2;
        const offsetY = (canvas.height - 400 * scale) / 2;

        frame.drones.forEach(d => {
            ctx.fillStyle = d.color;
            ctx.beginPath();
            ctx.arc(d.x * scale + offsetX, d.y * scale + offsetY, 4, 0, Math.PI * 2);
            ctx.fill();
        });

        // è½‰ Blob
        const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
        const fileName = `${filenamePrefix}_${String(i + 1).padStart(3, '0')}.png`;
        folder.file(fileName, blob);
    }

    // ä¸‹è¼‰
    const content = await zip.generateAsync({ type: "blob" });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(content);
    link.download = `${filenamePrefix}.zip`;
    link.click();
    setIsExporting(false);
  };

  // --- è¦–åœ–è½‰æ›èˆ‡äº’å‹• (ä¿æŒä¸è®Š) ---
  const getTransformMatrix = (canvasWidth, canvasHeight) => {
      const baseScale = Math.min(canvasWidth / 650, canvasHeight / 450);
      const baseOffsetX = (canvasWidth - 600 * baseScale) / 2;
      const baseOffsetY = (canvasHeight - 400 * baseScale) / 2;
      const cx = canvasWidth / 2;
      const cy = canvasHeight / 2;
      return {
          toScreen: (droneX, droneY) => {
              const bx = droneX * baseScale + baseOffsetX;
              const by = droneY * baseScale + baseOffsetY;
              const sx = cx + (bx - cx) * zoom + pan.x;
              const sy = cy + (by - cy) * zoom + pan.y;
              return { x: sx, y: sy, scale: baseScale * zoom };
          }
      };
  };

  const handleMouseDown = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    if (tool === 'view') { isPanningRef.current = true; lastMousePosRef.current = { x, y }; } 
    else if (tool === 'lasso') { isDrawingRef.current = true; lassoPathRef.current = [{x, y}]; }
  };
  const handleMouseMove = (e) => {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left; const y = e.clientY - rect.top;
    if (tool === 'view' && isPanningRef.current) {
        setPan(prev => ({ x: prev.x + (x - lastMousePosRef.current.x), y: prev.y + (y - lastMousePosRef.current.y) }));
        lastMousePosRef.current = { x, y };
    } else if (tool === 'lasso' && isDrawingRef.current) { lassoPathRef.current.push({x, y}); }
  };
  const handleMouseUp = () => {
    if (tool === 'view') isPanningRef.current = false;
    else if (tool === 'lasso') {
        isDrawingRef.current = false;
        // ... (Lasso logic same as before)
        const path = lassoPathRef.current;
        if (path.length > 2) {
             const canvas = canvasRef.current;
             const transform = getTransformMatrix(canvas.width, canvas.height);
             const newSelection = new Set();
             // ä½¿ç”¨ç•¶å‰é¡¯ç¤ºçš„ drones (å¯èƒ½æ˜¯ç·¨è¼¯ä¸­çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æ’­æ”¾ä¸­çš„)
             const activeDrones = currentFrameIndex >= 0 ? frames[currentFrameIndex].drones : drones;
             activeDrones.forEach((drone, index) => {
                 const screenPos = transform.toScreen(drone.x, drone.y);
                 if (isPointInPolygon(screenPos, path)) newSelection.add(index);
             });
             setSelectedIndices(newSelection);
        } else setSelectedIndices(new Set());
        lassoPathRef.current = [];
    }
  };
  const handleWheel = (e) => {
    if (e.ctrlKey) return;
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    setZoom(prev => Math.min(Math.max(prev + delta, 0.5), 5));
  };

  const updateSelectedColor = (newColor) => {
    if (selectedIndices.size === 0) return;
    // å¦‚æœæ˜¯é è¦½æ¨¡å¼ï¼Œä¸å…è¨±ä¿®æ”¹
    if (currentFrameIndex >= 0) return;
    
    setDrones(prev => prev.map((d, i) => selectedIndices.has(i) ? { ...d, color: newColor } : d));
  };

  // æ¸²æŸ“è¿´åœˆ
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    let animationId;
    
    const render = () => {
      if (canvas.parentElement) { canvas.width = canvas.parentElement.clientWidth; canvas.height = canvas.parentElement.clientHeight; }
      const transform = getTransformMatrix(canvas.width, canvas.height);

      ctx.fillStyle = '#0f172a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      const tl = transform.toScreen(0, 0); const br = transform.toScreen(600, 400);
      ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 1; ctx.strokeRect(tl.x, tl.y, br.x - tl.x, br.y - tl.y);

      const time = Date.now();
      
      // æ±ºå®šè¦æ¸²æŸ“çš„è³‡æ–™ï¼šç·¨è¼¯ä¸­ æˆ– æ™‚é–“è»¸é è¦½
      const displayDrones = currentFrameIndex >= 0 ? frames[currentFrameIndex].drones : drones;

      displayDrones.forEach((drone, index) => {
        const isHovering = !isPanningRef.current && !isDrawingRef.current;
        const hoverYOffset = isHovering ? Math.sin(time * 0.003 + drone.phase) * 2 : 0;
        const pos = transform.toScreen(drone.x, drone.y);
        const size = 3 * pos.scale; 
        
        if (selectedIndices.has(index)) {
            ctx.beginPath(); ctx.arc(pos.x, pos.y + hoverYOffset * zoom, size * 5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)'; ctx.fill();
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1; ctx.stroke();
        }

        ctx.globalCompositeOperation = 'screen';
        ctx.fillStyle = drone.color; 
        // é è¦½æ¨¡å¼ç¨å¾®æ·¡ä¸€é»
        ctx.globalAlpha = currentFrameIndex >= 0 ? 0.8 : 0.6; 
        ctx.beginPath(); ctx.arc(pos.x, pos.y + hoverYOffset * zoom, size * 3, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#ffffff'; ctx.globalAlpha = 1;
        ctx.beginPath(); ctx.arc(pos.x, pos.y + hoverYOffset * zoom, size, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
      });

      if (tool === 'lasso' && isDrawingRef.current && lassoPathRef.current.length > 0) {
          ctx.beginPath();
          lassoPathRef.current.forEach((p, i) => { if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y); });
          ctx.closePath(); ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2; ctx.setLineDash([5, 5]); ctx.stroke();
          ctx.fillStyle = 'rgba(0, 255, 204, 0.1)'; ctx.fill(); ctx.setLineDash([]);
      }
      animationId = requestAnimationFrame(render);
    };
    render();
    return () => cancelAnimationFrame(animationId);
  }, [drones, frames, currentFrameIndex, tool, selectedIndices, zoom, pan]);

  return (
    <div className="flex flex-col h-screen bg-slate-950 text-slate-200 font-sans overflow-hidden">
      <header className="flex items-center justify-between px-6 py-4 bg-slate-900 border-b border-slate-800 shrink-0">
        <div className="flex items-center gap-3">
          <div className="bg-indigo-600 p-2 rounded-lg shadow-lg"><Grid size={24} className="text-white" /></div>
          <div><h1 className="text-xl font-bold tracking-wide text-white">Drone Show Editor</h1></div>
        </div>
        <div className="flex gap-4">
             {/* ç›®æ¨™æ•¸é‡è¨­å®šå€ */}
             <div className="bg-slate-800 px-3 py-1 rounded-lg border border-slate-700 flex items-center gap-3">
               <div className="flex flex-col">
                  <span className="text-[10px] text-slate-400">ç›®æ¨™æ•¸é‡</span>
                  <div className="flex items-center gap-2">
                    <input 
                       type="number" value={targetCount} onChange={e => setTargetCount(Number(e.target.value))} 
                       className="w-16 bg-transparent text-sm font-mono text-white border-b border-slate-600 focus:border-indigo-500 outline-none"
                    />
                    <button 
                       onClick={autoFitToCount} disabled={isAutoFitting}
                       className="bg-indigo-600 hover:bg-indigo-500 text-white text-[10px] px-2 py-1 rounded flex items-center gap-1 disabled:opacity-50"
                    >
                       {isAutoFitting ? 'è¨ˆç®—ä¸­...' : <><Calculator size={10}/> è‡ªå‹•é©é…</>}
                    </button>
                  </div>
               </div>
               <div className="w-px h-8 bg-slate-700 mx-1"></div>
               <div className="flex flex-col items-end">
                   <span className="text-[10px] text-slate-400">ç•¶å‰æ•¸é‡</span>
                   <span className={`text-xl font-mono font-bold ${Math.abs(drones.length - targetCount) < targetCount * 0.1 ? 'text-green-400' : 'text-indigo-400'}`}>
                      {drones.length}
                   </span>
               </div>
            </div>
        </div>
      </header>

      <main className="flex flex-1 overflow-hidden">
        <aside className="w-80 bg-slate-900 border-r border-slate-800 flex flex-col overflow-y-auto z-20 shrink-0">
          <div className="p-6 space-y-6">
            <section className="space-y-3">
              <h2 className="text-xs font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2"><Layers size={14}/> 1. ä¾†æº</h2>
              <div className="grid grid-cols-2 gap-2 p-1 bg-slate-800 rounded-lg">
                <button onClick={() => setMode('text')} className={`flex items-center justify-center gap-2 py-2 rounded text-xs ${mode === 'text' ? 'bg-indigo-600 text-white' : 'text-slate-400'}`}><Type size={14}/> æ–‡å­—</button>
                <button onClick={() => setMode('image')} className={`flex items-center justify-center gap-2 py-2 rounded text-xs ${mode === 'image' ? 'bg-indigo-600 text-white' : 'text-slate-400'}`}><ImageIcon size={14}/> åœ–ç‰‡</button>
              </div>
              {mode === 'text' ? (
                <div className="p-3 bg-slate-800/50 rounded border border-slate-700 space-y-2">
                  <input type="text" value={inputText} onChange={(e) => setInputText(e.target.value)} className="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-white text-center" />
                  <input type="range" min="50" max="400" value={fontSize} onChange={(e)=>setFontSize(Number(e.target.value))} className="w-full h-1 bg-slate-700 rounded-lg appearance-none accent-indigo-500"/>
                </div>
              ) : (
                <div className="p-3 bg-slate-800/50 rounded border border-slate-700 text-center space-y-2">
                  <input type="file" ref={fileInputRef} onChange={handleImageUpload} accept="image/*" className="hidden" />
                  {imageSrc ? (
                    <div className="relative h-24 bg-white/5 rounded flex items-center justify-center"><img src={imageSrc} className="max-h-full max-w-full object-contain" /><button onClick={() => {setImageSrc(null); fileInputRef.current.value = null;}} className="absolute top-1 right-1 bg-red-500/80 p-1 rounded-full text-white"><Trash2 size={12}/></button></div>
                  ) : (
                    <div onClick={() => fileInputRef.current?.click()} className="border-2 border-dashed border-slate-600 rounded p-4 hover:border-indigo-500 cursor-pointer"><Upload className="mx-auto text-slate-500 mb-1" size={24}/><p className="text-xs text-slate-400">ä¸Šå‚³åœ–ç‰‡</p></div>
                  )}
                  <label className="flex items-center gap-2 text-[10px] text-slate-400 justify-center"><input type="checkbox" checked={bgRemovalEnabled} onChange={e => setBgRemovalEnabled(e.target.checked)}/> è‡ªå‹•é€€åœ°</label>
                </div>
              )}
            </section>

            <section className="space-y-3">
              <h2 className="text-xs font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2"><Settings size={14}/> 2. åƒæ•¸</h2>
              <div className="space-y-4">
                 <div className="space-y-1"><div className="flex justify-between text-[10px] text-slate-400"><span>å¯†åº¦ (Density)</span><span>{density}px</span></div><input type="range" min="3" max="25" value={density} onChange={(e) => setDensity(Number(e.target.value))} className="w-full h-1 bg-slate-700 rounded-lg accent-indigo-500"/></div>
                 <div className="space-y-1"><div className="flex justify-between text-[10px] text-slate-400"><span>åˆ¤å®šé–€æª» (Threshold)</span><span>{threshold}</span></div><input type="range" min="1" max="250" value={threshold} onChange={(e) => setThreshold(Number(e.target.value))} className="w-full h-1 bg-slate-700 rounded-lg accent-indigo-500"/></div>
              </div>
            </section>
            
            <section className="space-y-3">
               <h2 className="text-xs font-bold text-slate-500 uppercase tracking-widest flex items-center gap-2"><Palette size={14}/> 3. è‰²å½©</h2>
               <div className="flex gap-2"><button onClick={() => setUseImageColor(false)} className={`flex-1 py-1 text-[10px] rounded border ${!useImageColor ? 'bg-slate-700 border-white text-white' : 'border-slate-700 text-slate-500'}`}>å–®è‰²</button><button onClick={() => setUseImageColor(true)} className={`flex-1 py-1 text-[10px] rounded border ${useImageColor ? 'bg-slate-700 border-white text-white' : 'border-slate-700 text-slate-500'}`}>åŸè‰²</button></div>
               {!useImageColor && <div className="flex gap-1 flex-wrap">{['#00ffcc', '#ff0055', '#ffff00', '#0099ff', '#ffffff'].map(c => <button key={c} onClick={() => setSingleColor(c)} className={`w-5 h-5 rounded-full border ${singleColor === c ? 'border-white scale-110' : 'border-transparent'}`} style={{ backgroundColor: c }} />)}<input type="color" value={singleColor} onChange={(e) => setSingleColor(e.target.value)} className="w-5 h-5 p-0 border-0 rounded-full overflow-hidden"/></div>}
            </section>
          </div>
        </aside>

        <div className="flex-1 flex flex-col min-w-0 bg-black relative">
           {/* Canvas å€åŸŸ */}
           <div className="flex-1 relative overflow-hidden" 
                onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onWheel={handleWheel}>
             
             {/* é ‚éƒ¨å·¥å…·åˆ— */}
             <div className="absolute top-4 left-4 z-10 flex gap-2">
                <div className="bg-slate-900/90 backdrop-blur border border-slate-700 p-1 rounded flex gap-1">
                   <button onClick={() => setTool('view')} className={`p-1.5 rounded ${tool==='view'?'bg-slate-700 text-white':'text-slate-400'}`}><Move size={14}/></button>
                   <button onClick={() => setTool('lasso')} className={`p-1.5 rounded ${tool==='lasso'?'bg-indigo-600 text-white':'text-slate-400'}`}><Lasso size={14}/></button>
                </div>
                <div className="bg-slate-900/90 backdrop-blur border border-slate-700 p-1 rounded flex gap-1 items-center px-2">
                   <button onClick={()=>setZoom(z=>Math.max(z-0.2,0.5))} className="text-slate-400 hover:text-white"><ZoomOut size={14}/></button>
                   <span className="text-[10px] w-8 text-center">{Math.round(zoom*100)}%</span>
                   <button onClick={()=>setZoom(z=>Math.min(z+0.2,5))} className="text-slate-400 hover:text-white"><ZoomIn size={14}/></button>
                   <button onClick={()=>{setZoom(1);setPan({x:0,y:0})}} className="ml-2 text-slate-400 hover:text-white"><Maximize size={14}/></button>
                </div>
             </div>

             {/* é è¦½æ’­æ”¾æŒ‡ç¤ºå™¨ */}
             {currentFrameIndex >= 0 && (
                 <div className="absolute top-4 right-4 z-10 bg-red-500/20 text-red-400 border border-red-500/50 px-3 py-1 rounded-full text-xs font-bold animate-pulse flex items-center gap-2">
                     <Play size={10} fill="currentColor"/> PREVIEWING FRAME {currentFrameIndex + 1}
                 </div>
             )}

             <canvas ref={canvasRef} className={`block w-full h-full ${tool==='lasso'?'cursor-crosshair':tool==='view'?'cursor-move':'cursor-default'}`} />
             
             {/* æ‰¹é‡ä¿®æ”¹ Popup */}
             {selectedIndices.size > 0 && currentFrameIndex === -1 && (
               <div className="absolute bottom-4 left-1/2 -translate-x-1/2 bg-slate-800 border border-indigo-500 rounded-full px-4 py-2 flex items-center gap-3 shadow-xl">
                  <span className="text-xs font-bold text-white flex items-center gap-1"><CheckCircle2 size={12} className="text-indigo-400"/> {selectedIndices.size} é¸å–</span>
                  <div className="h-3 w-px bg-slate-600"></div>
                  <div className="flex gap-1">{['#00ffcc', '#ff0055', '#ffff00', '#ffffff'].map(c => <button key={c} onClick={() => updateSelectedColor(c)} className="w-3 h-3 rounded-full" style={{ backgroundColor: c }} />)}</div>
                  <button onClick={() => setSelectedIndices(new Set())}><X size={14} className="text-slate-400 hover:text-white"/></button>
               </div>
             )}
           </div>

           {/* åº•éƒ¨æ™‚é–“è»¸èˆ‡åŒ¯å‡ºå€åŸŸ */}
           <div className="h-48 bg-slate-900 border-t border-slate-800 flex flex-col shrink-0">
              
              {/* æ§åˆ¶åˆ— */}
              <div className="h-10 border-b border-slate-800 flex items-center justify-between px-4 bg-slate-900/50">
                 <div className="flex items-center gap-2">
                    <span className="text-xs font-bold text-slate-400 flex items-center gap-2"><Film size={14}/> TIMELINE</span>
                    <div className="h-4 w-px bg-slate-700 mx-2"></div>
                    <button 
                       onClick={addFrame} disabled={drones.length === 0 || currentFrameIndex !== -1}
                       className="flex items-center gap-1 bg-indigo-600 hover:bg-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed text-white text-xs px-2 py-1 rounded transition-colors"
                    >
                       <PlusSquare size={12}/> åŠ å…¥ç•«æ ¼
                    </button>
                    <button 
                       onClick={playTimeline} disabled={frames.length === 0}
                       className={`flex items-center gap-1 px-2 py-1 rounded text-xs transition-colors ${isPlaying ? 'bg-red-500/20 text-red-400' : 'bg-slate-700 text-slate-200 hover:bg-slate-600'}`}
                    >
                       {isPlaying ? <><Pause size={12}/> æš«åœ</> : <><Play size={12}/> æ’­æ”¾</>}
                    </button>
                 </div>

                 {/* åŒ¯å‡ºå€ */}
                 <div className="flex items-center gap-2">
                    <span className="text-[10px] text-slate-500">æª”å:</span>
                    <input 
                      type="text" value={filenamePrefix} onChange={e => setFilenamePrefix(e.target.value)}
                      className="bg-slate-800 border border-slate-700 rounded px-2 py-0.5 text-xs text-white w-24 outline-none focus:border-indigo-500"
                    />
                    <button 
                       onClick={exportZip} disabled={frames.length === 0 || isExporting}
                       className="flex items-center gap-1 bg-green-600 hover:bg-green-500 disabled:opacity-50 text-white text-xs px-2 py-1 rounded"
                    >
                       {isExporting ? 'æ‰“åŒ…ä¸­...' : <><Save size={12}/> åŒ¯å‡º ZIP</>}
                    </button>
                 </div>
              </div>

              {/* ç¸®åœ–åˆ—è¡¨ */}
              <div className="flex-1 overflow-x-auto p-4 flex gap-3 items-center">
                 {frames.length === 0 ? (
                    <div className="text-slate-600 text-xs flex flex-col items-center justify-center w-full h-full border-2 border-dashed border-slate-800 rounded-lg">
                       <Film size={24} className="mb-2 opacity-50"/>
                       <p>é»æ“Šã€ŒåŠ å…¥ç•«æ ¼ã€é–‹å§‹è£½ä½œå‹•ç•«</p>
                    </div>
                 ) : (
                    frames.map((frame, idx) => (
                       <div 
                         key={frame.id}
                         onClick={() => {
                             setCurrentFrameIndex(-1); // é»æ“Šç·¨è¼¯
                             setDrones(frame.drones); // è¼‰å…¥è©²å¹€æ•¸æ“š
                         }}
                         className={`relative group shrink-0 w-32 h-24 bg-slate-800 rounded border-2 cursor-pointer transition-all ${currentFrameIndex === idx ? 'border-yellow-500 shadow-[0_0_10px_rgba(234,179,8,0.3)]' : 'border-slate-700 hover:border-indigo-500'}`}
                       >
                          <img src={frame.thumbnail} className="w-full h-full object-contain p-1" />
                          <div className="absolute top-1 left-1 bg-black/50 px-1.5 rounded text-[10px] text-white font-mono">{String(idx + 1).padStart(2, '0')}</div>
                          <button 
                             onClick={(e) => deleteFrame(idx, e)}
                             className="absolute top-1 right-1 bg-red-500/80 p-1 rounded opacity-0 group-hover:opacity-100 transition-opacity text-white hover:bg-red-600"
                          >
                             <X size={10}/>
                          </button>
                          <div className="absolute bottom-1 right-1 bg-black/50 px-1 rounded text-[9px] text-slate-300">{frame.drones.length} pts</div>
                       </div>
                    ))
                 )}
              </div>
           </div>
        </div>
      </main>
    </div>
  );
}
